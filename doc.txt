ğŸ”§ 1. Understand What the Shell (witsshell) Must Do

Your shell (witsshell) must:

Run in interactive mode (prompt: witsshell>) or batch mode (read commands from a file).

Repeatedly:

Show prompt (interactive mode).

Parse a line of user input.

Execute that line as a program (with arguments).

Wait for the program to finish.

Exit on the built-in command exit.

Think of it like this:

int main(int argc, char *argv[]) {
    if (argc == 1) {
        // Interactive Mode
    } else if (argc == 2) {
        // Batch Mode (read commands from argv[1])
    } else {
        // Too many arguments: show error and exit
    }
}

ğŸ§  2. Figure Out the Connection Between the Shell and Buddy Allocator

This is where itâ€™s easy to get confused.

The file buddy.c and buddy.h are meant to replace or augment malloc/free in your shell. So the shell might be using the buddy allocator to manage memory instead of standard allocation.

You need to:

Build witsshell.c to run user commands.

Use the functions balloc and bfree from buddy.c when you need to allocate memory (e.g., for storing user input, command arguments, etc.).

You donâ€™t start in buddy.c â€” that's just a memory tool. You start with the shell logic.

ğŸ—‚ 3. Project Folder Structure

Your folder probably looks something like:

project/
â”‚
â”œâ”€â”€ witsshell.c         # Your shell program (you will write this)
â”œâ”€â”€ buddy.c             # Given - implements buddy allocator
â”œâ”€â”€ buddy.h             # Header for buddy allocator
â””â”€â”€ Makefile            # (Optional) For building everything

ğŸ§ª 4. Development Plan â€“ Start Small
Step 1: Build the basic shell loop in witsshell.c

Start with just reading input and printing it back.

Add command execution with fork() + execvp() + waitpid().

Add support for exit built-in.

Step 2: Add batch mode

Check if a file is passed as argument.

Read lines from file instead of standard input.

No prompt in this mode.

Step 3: Add input parsing

Split input line into command and arguments.

Use strtok() or equivalent.

Step 4: Use buddy allocator

Replace malloc() calls with balloc().

Replace free() calls with bfree().

ğŸ“˜ 5. Track What You Still Need to Do in buddy.c

In buddy.c, youâ€™re missing the implementation for:

new(): Create and initialize a buddy allocator.

level(int req): Return the smallest block level that can hold req bytes.

balloc(size): Allocate memory using buddy system.

bfree(ptr): Free memory back into buddy system.

Don't worry about these yet if you're unsure â€” you can mock balloc() using malloc() first, and come back to implement buddy later.

âœ… What You Should Do First

Start with the following steps in order:

Create witsshell.c and stub out main() with argc check.

Implement interactive mode loop:

Show prompt.

Read input.

Parse command.

Use fork()/execvp()/waitpid() to run it.

Add support for batch mode (reading from a file).

Add support for the exit command.

Only after that: integrate buddy allocator (replace malloc/free).

Then implement missing logic in buddy.c.

ğŸ§° Helpful Functions for Shell

You'll likely use:

fgets() â€“ read user input.

strtok() â€“ parse input into tokens.

fork() â€“ create new process.

execvp() â€“ execute command-finding path automatically.

waitpid() â€“ wait for child.

strcmp() â€“ compare strings (for exit command).


-------------------------------------------------------------------------------------------------

1.Your shell does NOT implement commands like ls, echo, or cat.

    You donâ€™t write the logic for listing files or printing text yourself.
    Those are programs that already exist on the system (usually in /bin/ or /usr/bin/).

2.What your shell does:

    Reads a command line from the user (or batch file).
    Parses it into command + arguments (argv_tk).
    Searches a path list (like /bin/) to find the executable file.
    Forks a child process and calls execv() to run the found program.
    Waits for the child to finish.
    Handles built-in commands like exit yourself.

-----------------------------------------------------------------------------------------------------------------
#############################  Buddy Allocator ##############################

Example:

    Original 1 KB block starts at address 0x1000

    Split â†’ left half = 0x1000 (original block)

    Right half (buddy) = 0x1200 (buddy_block)


Initialize the right half of the split:

Mark it Free

Set level = i (current level = 4 â†’ size = 512B)

Insert into freelist[4] at the head of the linked list

Now freelist[4] contains the right 512B block

    buddy_block->status = Free;
    buddy_block->level = i;
    buddy_block->next = free_lists[i];
    buddy_block->prev = NULL;
    if(free_lists[i]){
    free_lists[i]->prev = buddy_block;
    }
    free_lists[i] = buddy_block;



Update the original block (left half):

Its size is now 512B â†’ level = 4

Reset links because itâ€™s being handled separately

    block->level = i;
    block->next = NULL;
    block->prev = NULL;




Mark the final block as allocated

Left block of size 128B is now Taken

hide(block) returns pointer after the header, i.e., the usable memory for the user

User now gets 128B usable memory

    block->status = Taken;
    return hide(block); // return pointer to memory after the header

